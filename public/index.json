[{"content":"","date":null,"permalink":"https://jaredszajkowski.github.io/jaredszajkowski.github.io_congo/topics/federal-reserve-data/","section":"Topics","summary":"","title":"Federal Reserve Data"},{"content":"","date":null,"permalink":"https://jaredszajkowski.github.io/jaredszajkowski.github.io_congo/","section":"Jared Szajkowski","summary":"","title":"Jared Szajkowski"},{"content":"","date":null,"permalink":"https://jaredszajkowski.github.io/jaredszajkowski.github.io_congo/topics/pandas/","section":"Topics","summary":"","title":"Pandas"},{"content":"Introduction #In this post, we will look into the Fed Funds cycles and evaluate asset class performance during loosening and tightening of monetary policy.\nPython Functions #Here are the functions needed for this project:\ncalc_fed_cycle_asset_performance: Calculates the performance of various asset classes during the Fed Funds cycles. df_info: A simple function to display the information about a DataFrame and the first five rows and last five rows. df_info_markdown: Similar to the df_info function above, except that it coverts the output to markdown. export_track_md_deps: Exports various text outputs to markdown files, which are included in the index.md file created when building the site with Hugo. load_data: Load data from a CSV, Excel, or Pickle file into a pandas DataFrame. pandas_set_decimal_places: Set the number of decimal places displayed for floating-point numbers in pandas. plot_bar_returns_ffr_change: Plot the bar chart of the cumulative or annualized returns for the asset class along with the change in the Fed Funds Rate. plot_timeseries: Plot the timeseries data from a DataFrame for a specified date range and columns. plot_scatter_regression_ffr_vs_returns: Plot the scatter plot and regression of the annualized return for the asset class along with the annualized change in the Fed Funds Rate. yf_pull_data: Download daily price data from Yahoo Finance and export it. Data Overview #Acquire \u0026amp; Plot Fed Funds Data #First, let\u0026rsquo;s get the data for the Fed Funds rate (FFR):\n# Set decimal places pandas_set_decimal_places(4) # Pull Effective Fed Funds Rate from FRED fedfunds = web.DataReader(\u0026#34;FEDFUNDS\u0026#34;, \u0026#34;fred\u0026#34;, start=\u0026#34;1900-01-01\u0026#34;, end=datetime.today()) fedfunds[\u0026#34;FEDFUNDS\u0026#34;] = fedfunds[\u0026#34;FEDFUNDS\u0026#34;] / 100 # Convert to decimal # Resample to monthly frequency and compute change in rate fedfunds_monthly = fedfunds.resample(\u0026#34;M\u0026#34;).last() fedfunds_monthly = fedfunds_monthly[(fedfunds_monthly.index \u0026gt;= pd.to_datetime(start_date)) \u0026amp; (fedfunds_monthly.index \u0026lt;= pd.to_datetime(end_date))] fedfunds_monthly[\u0026#34;FedFunds_Change\u0026#34;] = fedfunds_monthly[\u0026#34;FEDFUNDS\u0026#34;].diff() This gives us:\nThe columns, shape, and data types are: \u0026lt;class \u0026#39;pandas.core.frame.DataFrame\u0026#39;\u0026gt; DatetimeIndex: 252 entries, 2004-11-30 to 2025-10-31 Freq: ME Data columns (total 2 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 FEDFUNDS 252 non-null float64 1 FedFunds_Change 251 non-null float64 dtypes: float64(2) memory usage: 5.9 KB The first 5 rows are: | DATE | FEDFUNDS | FedFunds_Change | |:--------------------|-----------:|------------------:| | 2004-11-30 00:00:00 | 0.0193 | nan | | 2004-12-31 00:00:00 | 0.0216 | 0.0023 | | 2005-01-31 00:00:00 | 0.0228 | 0.0012 | | 2005-02-28 00:00:00 | 0.0250 | 0.0022 | | 2005-03-31 00:00:00 | 0.0263 | 0.0013 | The last 5 rows are: | DATE | FEDFUNDS | FedFunds_Change | |:--------------------|-----------:|------------------:| | 2025-06-30 00:00:00 | 0.0433 | 0.0000 | | 2025-07-31 00:00:00 | 0.0433 | 0.0000 | | 2025-08-31 00:00:00 | 0.0433 | 0.0000 | | 2025-09-30 00:00:00 | 0.0422 | -0.0011 | | 2025-10-31 00:00:00 | 0.0409 | -0.0013 | We can then generate several useful visual aids (plots). First, the FFR from the beginning of our data set (11/2004):\nplot_timeseries( price_df=fedfunds_monthly, plot_start_date=start_date, plot_end_date=end_date, plot_columns=[\u0026#34;FEDFUNDS\u0026#34;], title=\u0026#34;Fed Funds Rate\u0026#34;, x_label=\u0026#34;Date\u0026#34;, x_format=\u0026#34;Year\u0026#34;, y_label=\u0026#34;Rate (%)\u0026#34;, y_format=\u0026#34;Percentage\u0026#34;, y_format_decimal_places=1, y_tick_spacing=0.005, grid=True, legend=False, export_plot=True, plot_file_name=\u0026#34;01_Fed_Funds_Rate\u0026#34;, ) And then the change in FFR from month-to-month:\nplot_timeseries( price_df=fedfunds_monthly, plot_start_date=start_date, plot_end_date=end_date, plot_columns=[\u0026#34;FedFunds_Change\u0026#34;], title=\u0026#34;Fed Funds Change In Rate\u0026#34;, x_label=\u0026#34;Date\u0026#34;, x_format=\u0026#34;Year\u0026#34;, y_label=\u0026#34;Rate (%)\u0026#34;, y_format=\u0026#34;Percentage\u0026#34;, y_format_decimal_places=2, y_tick_spacing=0.0025, grid=True, legend=False, export_plot=True, plot_file_name=\u0026#34;01_Fed_Funds_Change_In_Rate\u0026#34;, ) This plot, in particular, makes it easy to show the monthly increase and decrease in the FFR, as well as the magnitude of the change (i.e. slow, drawn-out increases or decreases or abrupt large increases or decreases).\nDefine Fed Policy Cycles #Next, we will define the Fed policy tightening and loosening cycles. This is done via visual inspection of the FFR plot and establishing some timeframes for when the cycles started and ended. Here\u0026rsquo;s the list of cycles:\n# Define manually specified Fed policy cycles fed_cycles = [ (\u0026#34;2004-11-01\u0026#34;, \u0026#34;2006-07-01\u0026#34;), (\u0026#34;2006-07-01\u0026#34;, \u0026#34;2007-07-01\u0026#34;), (\u0026#34;2007-07-01\u0026#34;, \u0026#34;2008-12-01\u0026#34;), (\u0026#34;2008-12-01\u0026#34;, \u0026#34;2015-11-01\u0026#34;), (\u0026#34;2015-11-01\u0026#34;, \u0026#34;2019-01-01\u0026#34;), (\u0026#34;2019-01-01\u0026#34;, \u0026#34;2019-07-01\u0026#34;), (\u0026#34;2019-07-01\u0026#34;, \u0026#34;2020-04-01\u0026#34;), (\u0026#34;2020-04-01\u0026#34;, \u0026#34;2022-02-01\u0026#34;), (\u0026#34;2022-02-01\u0026#34;, \u0026#34;2023-08-01\u0026#34;), (\u0026#34;2023-08-01\u0026#34;, \u0026#34;2024-08-01\u0026#34;), (\u0026#34;2024-08-01\u0026#34;, datetime.today().strftime(\u0026#39;%Y-%m-%d\u0026#39;)), ] # Optional: assign a name to each cycle cycle_labels = [f\u0026#34;Cycle {i+1}\u0026#34; for i in range(len(fed_cycles))] And here\u0026rsquo;s the list of total change in the FFR corresponding to each cycle:\n# Set decimal places pandas_set_decimal_places(4) # Calc changes by fed cycle defined above fed_changes = [] for (start, end) in fed_cycles: start = pd.to_datetime(start) end = pd.to_datetime(end) try: rate_start = fedfunds.loc[start, \u0026#34;FEDFUNDS\u0026#34;] except KeyError: rate_start = fedfunds.loc[:start].iloc[-1][\u0026#34;FEDFUNDS\u0026#34;] try: rate_end = fedfunds.loc[end, \u0026#34;FEDFUNDS\u0026#34;] except KeyError: rate_end = fedfunds.loc[:end].iloc[-1][\u0026#34;FEDFUNDS\u0026#34;] change = rate_end - rate_start fed_changes.append(change) fed_changes_df = pd.DataFrame({ \u0026#34;Cycle\u0026#34;: cycle_labels, \u0026#34;FedFunds_Change\u0026#34;: fed_changes }) Which gives us the following cycles and cumulative change in rate per cycle:\n| | Cycle | FedFunds_Change | |---:|:---------|------------------:| | 0 | Cycle 1 | 0.0331 | | 1 | Cycle 2 | 0.0002 | | 2 | Cycle 3 | -0.0510 | | 3 | Cycle 4 | -0.0004 | | 4 | Cycle 5 | 0.0228 | | 5 | Cycle 6 | 0.0000 | | 6 | Cycle 7 | -0.0235 | | 7 | Cycle 8 | 0.0003 | | 8 | Cycle 9 | 0.0525 | | 9 | Cycle 10 | 0.0000 | | 10 | Cycle 11 | -0.0145 | Return Performance By Fed Policy Cycle #Moving on, we will now look at the performance of three (3) different asset classes during each Fed cycle. We\u0026rsquo;ll use SPY as a proxy for stocks, TLT as a proxy for bonds, and GLD as a proxy for gold. These datasets are slightly limiting due to the availability of all 3 starting in late 2004, but will work for our simple exercise. In a future post, we\u0026rsquo;ll look to use Bloomberg indices instead.\nStocks (SPY) #First, we pull data for SPY with the following:\n# Set decimal places pandas_set_decimal_places(2) yf_pull_data( base_directory=DATA_DIR, ticker=\u0026#34;SPY\u0026#34;, source=\u0026#34;Yahoo_Finance\u0026#34;, asset_class=\u0026#34;Exchange_Traded_Funds\u0026#34;, excel_export=True, pickle_export=True, output_confirmation=True, ) And then load data with the following:\nspy = load_data( base_directory=DATA_DIR, ticker=\u0026#34;SPY\u0026#34;, source=\u0026#34;Yahoo_Finance\u0026#34;, asset_class=\u0026#34;Exchange_Traded_Funds\u0026#34;, timeframe=\u0026#34;Daily\u0026#34;, file_format=\u0026#34;pickle\u0026#34;, ) # Filter SPY to date range spy = spy[(spy.index \u0026gt;= pd.to_datetime(start_date)) \u0026amp; (spy.index \u0026lt;= pd.to_datetime(end_date))] # Resample to monthly frequency spy_monthly = spy.resample(\u0026#34;M\u0026#34;).last() spy_monthly[\u0026#34;Monthly_Return\u0026#34;] = spy_monthly[\u0026#34;Close\u0026#34;].pct_change() Which gives us the following:\nThe columns, shape, and data types are: \u0026lt;class \u0026#39;pandas.core.frame.DataFrame\u0026#39;\u0026gt; DatetimeIndex: 252 entries, 2004-11-30 to 2025-10-31 Freq: ME Data columns (total 6 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Close 252 non-null float64 1 High 252 non-null float64 2 Low 252 non-null float64 3 Open 252 non-null float64 4 Volume 252 non-null int64 5 Monthly_Return 251 non-null float64 dtypes: float64(5), int64(1) memory usage: 13.8 KB The first 5 rows are: | Date | Close | High | Low | Open | Volume | Monthly_Return | |:--------------------|--------:|-------:|------:|-------:|------------:|-----------------:| | 2004-11-30 00:00:00 | 79.60 | 79.83 | 79.43 | 79.67 | 53685200.00 | nan | | 2004-12-31 00:00:00 | 81.99 | 82.53 | 81.95 | 82.28 | 28648800.00 | 0.03 | | 2005-01-31 00:00:00 | 80.15 | 80.22 | 79.85 | 80.01 | 52532700.00 | -0.02 | | 2005-02-28 00:00:00 | 81.83 | 82.28 | 81.43 | 82.18 | 69381300.00 | 0.02 | | 2005-03-31 00:00:00 | 80.33 | 80.67 | 80.27 | 80.49 | 64575400.00 | -0.02 | The last 5 rows are: | Date | Close | High | Low | Open | Volume | Monthly_Return | |:--------------------|--------:|-------:|-------:|-------:|-------------:|-----------------:| | 2025-06-30 00:00:00 | 614.33 | 615.69 | 611.53 | 613.86 | 92502500.00 | 0.05 | | 2025-07-31 00:00:00 | 628.48 | 636.20 | 627.17 | 635.81 | 103385200.00 | 0.02 | | 2025-08-31 00:00:00 | 641.37 | 644.15 | 639.47 | 643.78 | 74522200.00 | 0.02 | | 2025-09-30 00:00:00 | 664.22 | 664.69 | 659.66 | 660.98 | 86288000.00 | 0.04 | | 2025-10-31 00:00:00 | 680.05 | 683.06 | 677.24 | 683.02 | 87164100.00 | 0.02 | Next, we can plot the price history before calculating the cycle performance:\nplot_timeseries( price_df=spy, plot_start_date=start_date, plot_end_date=end_date, plot_columns=[\u0026#34;Close\u0026#34;], title=\u0026#34;SPY Close Price\u0026#34;, x_label=\u0026#34;Date\u0026#34;, x_format=\u0026#34;Year\u0026#34;, y_label=\u0026#34;Price ($)\u0026#34;, y_format=\u0026#34;Decimal\u0026#34;, y_tick_spacing=50, grid=True, legend=False, export_plot=True, plot_file_name=\u0026#34;02_SPY_Price\u0026#34;, y_format_decimal_places=0, ) Next, we will calculate the performance for SPY based on the pre-defined Fed cycles:\nspy_cycle_df = calc_fed_cycle_asset_performance( fed_cycles=fed_cycles, cycle_labels=cycle_labels, fed_changes=fed_changes, monthly_df=spy_monthly, ) Which gives us:\n| | Cycle | Start | End | Months | CumulativeReturn | CumulativeReturnPct | AverageMonthlyReturn | AverageMonthlyReturnPct | AnnualizedReturn | AnnualizedReturnPct | Volatility | FedFundsChange | FedFundsChange_bps | FFR_AnnualizedChange | FFR_AnnualizedChange_bps | Label | |---:|:---------|:-----------|:-----------|---------:|-------------------:|----------------------:|-----------------------:|--------------------------:|-------------------:|----------------------:|-------------:|-----------------:|---------------------:|-----------------------:|---------------------------:|:-----------------------------------| | 0 | Cycle 1 | 2004-11-01 | 2006-07-01 | 20 | 0.11 | 11.32 | 0.01 | 0.59 | 0.07 | 6.64 | 0.08 | 0.03 | 331.00 | 0.02 | 198.60 | Cycle 1, 2004-11-01 to 2006-07-01 | | 1 | Cycle 2 | 2006-07-01 | 2007-07-01 | 12 | 0.20 | 20.36 | 0.02 | 1.57 | 0.20 | 20.36 | 0.07 | 0.00 | 2.00 | 0.00 | 2.00 | Cycle 2, 2006-07-01 to 2007-07-01 | | 2 | Cycle 3 | 2007-07-01 | 2008-12-01 | 17 | -0.39 | -38.55 | -0.03 | -2.67 | -0.29 | -29.09 | 0.19 | -0.05 | -510.00 | -0.04 | -360.00 | Cycle 3, 2007-07-01 to 2008-12-01 | | 3 | Cycle 4 | 2008-12-01 | 2015-11-01 | 83 | 1.67 | 167.34 | 0.01 | 1.28 | 0.15 | 15.28 | 0.15 | -0.00 | -4.00 | -0.00 | -0.58 | Cycle 4, 2008-12-01 to 2015-11-01 | | 4 | Cycle 5 | 2015-11-01 | 2019-01-01 | 38 | 0.28 | 28.30 | 0.01 | 0.70 | 0.08 | 8.19 | 0.11 | 0.02 | 228.00 | 0.01 | 72.00 | Cycle 5, 2015-11-01 to 2019-01-01 | | 5 | Cycle 6 | 2019-01-01 | 2019-07-01 | 6 | 0.18 | 18.33 | 0.03 | 2.95 | 0.40 | 40.01 | 0.18 | 0.00 | 0.00 | 0.00 | 0.00 | Cycle 6, 2019-01-01 to 2019-07-01 | | 6 | Cycle 7 | 2019-07-01 | 2020-04-01 | 9 | -0.11 | -10.67 | -0.01 | -1.10 | -0.14 | -13.96 | 0.19 | -0.02 | -235.00 | -0.03 | -313.33 | Cycle 7, 2019-07-01 to 2020-04-01 | | 7 | Cycle 8 | 2020-04-01 | 2022-02-01 | 22 | 0.79 | 79.13 | 0.03 | 2.78 | 0.37 | 37.43 | 0.16 | 0.00 | 3.00 | 0.00 | 1.64 | Cycle 8, 2020-04-01 to 2022-02-01 | | 8 | Cycle 9 | 2022-02-01 | 2023-08-01 | 18 | 0.04 | 4.18 | 0.00 | 0.40 | 0.03 | 2.77 | 0.21 | 0.05 | 525.00 | 0.03 | 350.00 | Cycle 9, 2022-02-01 to 2023-08-01 | | 9 | Cycle 10 | 2023-08-01 | 2024-08-01 | 12 | 0.22 | 22.00 | 0.02 | 1.75 | 0.22 | 22.00 | 0.15 | 0.00 | 0.00 | 0.00 | 0.00 | Cycle 10, 2023-08-01 to 2024-08-01 | | 10 | Cycle 11 | 2024-08-01 | 2025-12-22 | 15 | 0.26 | 25.72 | 0.02 | 1.59 | 0.20 | 20.09 | 0.11 | -0.01 | -145.00 | -0.01 | -116.00 | Cycle 11, 2024-08-01 to 2025-12-22 | This gives us the following data points:\nCycle start date Cycle end date Number of months in the cycle Cumulative return during the cycle (decimal and percent) Average monthly return during the cycle (decimal and percent) Annualized return during the cycle (decimal and percent) Return volatility during the cycle Cumulative change in FFR during the cycle (decimal and basis points) Annualized change in FFR during the cycle (decimal and basis points) From the above DataFrame, we can then plot the cumulative and annualized returns for each cycle in a bar chart. First, the cumulative returns along with the cumulative change in FFR:\nAnd then the annualized returns along with the annualized change in FFR:\nThe cumulative returns plot is not particularly insightful, but there are some interesting observations to be gained from the annualized returns plot. During the past two (2) rate cutting cycles (cycles 3 and 7), stocks have exhibited negative returns during the rate cutting cycle. However, after the rate cutting cycle was complete, returns during the following cycle (when rates were usually flat) were quite strong and higher than the historical mean return for the S\u0026amp;P 500. The economic intuition for this behavior is valid; as the economy weakens, investors are concerned about the pricing of equities, the returns become negative, and the Fed responds with cutting rates. The exact timing of when the Fed begins cutting rates is one of the unknowns; the Fed could be ahead of the curve, cutting rates as economic data begins to prompt that action, or behind the curve, where the ecomony rolls over rapidly and even the Fed\u0026rsquo;s actions are not enough to halt the economic contraction.\nFinally, we can run an OLS regression to check fit:\ndf = spy_cycle_df #################################### ### Don\u0026#39;t modify below this line ### #################################### # Run OLS regression with statsmodels X = df[\u0026#34;FFR_AnnualizedChange_bps\u0026#34;] y = df[\u0026#34;AnnualizedReturnPct\u0026#34;] X = sm.add_constant(X) model = sm.OLS(y, X).fit() print(model.summary()) print(f\u0026#34;Intercept: {model.params[0]}, Slope: {model.params[1]}\u0026#34;) # Intercept and slope # Calc X and Y values for regression line X_vals = np.linspace(X.min(), X.max(), 100) Y_vals = model.params[0] + model.params[1] * X_vals Which gives us the results of the OLS regression:\nOLS Regression Results =============================================================================== Dep. Variable: AnnualizedReturnPct R-squared: 0.180 Model: OLS Adj. R-squared: 0.089 Method: Least Squares F-statistic: 1.973 Date: Mon, 22 Dec 2025 Prob (F-statistic): 0.194 Time: 20:58:51 Log-Likelihood: -47.173 No. Observations: 11 AIC: 98.35 Df Residuals: 9 BIC: 99.14 Df Model: 1 Covariance Type: nonrobust ============================================================================================ coef std err t P\u0026gt;|t| [0.025 0.975] -------------------------------------------------------------------------------------------- const 12.4404 5.894 2.111 0.064 -0.893 25.774 FFR_AnnualizedChange_bps 0.0430 0.031 1.405 0.194 -0.026 0.112 ============================================================================== Omnibus: 1.065 Durbin-Watson: 3.078 Prob(Omnibus): 0.587 Jarque-Bera (JB): 0.665 Skew: 0.026 Prob(JB): 0.717 Kurtosis: 1.796 Cond. No. 193. ============================================================================== Notes: [1] Standard Errors assume that the covariance matrix of the errors is correctly specified. And then plot the regression line along with the values:\nplot_scatter_regression_ffr_vs_returns( cycle_df=spy_cycle_df, asset_label=\u0026#34;SPY\u0026#34;, index_num=\u0026#34;02\u0026#34;, x_vals=X_vals, y_vals=Y_vals, intercept=model.params[0], slope=model.params[1], ) Which gives us:\nHere we can see the data points for cycles 3 and 7 as mentioned above. Ignoring the data points where the annualized change in FFR is roughly zero (cycles 2, 4, 6, 8, and 10), cycles 1, 5, and 9 fit the economic thesis above, and cycle 11 (which is the current rate cutting cycle), stands as an outlier. Of course, the book is not yet finished for cycle 11, and we could certainly see a bear market in stocks over the next several years.\nBonds (TLT) #Next, we\u0026rsquo;ll run a similar process for long term bonds using TLT as the proxy.\nFirst, we pull data with the following:\n# Set decimal places pandas_set_decimal_places(2) yf_pull_data( base_directory=DATA_DIR, ticker=\u0026#34;TLT\u0026#34;, source=\u0026#34;Yahoo_Finance\u0026#34;, asset_class=\u0026#34;Exchange_Traded_Funds\u0026#34;, excel_export=True, pickle_export=True, output_confirmation=True, ) And then load data with the following:\ntlt = load_data( base_directory=DATA_DIR, ticker=\u0026#34;TLT\u0026#34;, source=\u0026#34;Yahoo_Finance\u0026#34;, asset_class=\u0026#34;Exchange_Traded_Funds\u0026#34;, timeframe=\u0026#34;Daily\u0026#34;, file_format=\u0026#34;pickle\u0026#34;, ) # Filter TLT to date range tlt = tlt[(tlt.index \u0026gt;= pd.to_datetime(start_date)) \u0026amp; (tlt.index \u0026lt;= pd.to_datetime(end_date))] # Resample to monthly frequency tlt_monthly = tlt.resample(\u0026#34;M\u0026#34;).last() tlt_monthly[\u0026#34;Monthly_Return\u0026#34;] = tlt_monthly[\u0026#34;Close\u0026#34;].pct_change() Gives us the following:\nThe columns, shape, and data types are: \u0026lt;class \u0026#39;pandas.core.frame.DataFrame\u0026#39;\u0026gt; DatetimeIndex: 252 entries, 2004-11-30 to 2025-10-31 Freq: ME Data columns (total 6 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Close 252 non-null float64 1 High 252 non-null float64 2 Low 252 non-null float64 3 Open 252 non-null float64 4 Volume 252 non-null int64 5 Monthly_Return 251 non-null float64 dtypes: float64(5), int64(1) memory usage: 13.8 KB The first 5 rows are: | Date | Close | High | Low | Open | Volume | Monthly_Return | |:--------------------|--------:|-------:|------:|-------:|-----------:|-----------------:| | 2004-11-30 00:00:00 | 43.80 | 43.91 | 43.64 | 43.80 | 1754500.00 | nan | | 2004-12-31 00:00:00 | 44.96 | 45.01 | 44.84 | 44.87 | 1056400.00 | 0.03 | | 2005-01-31 00:00:00 | 46.57 | 46.59 | 46.35 | 46.37 | 1313900.00 | 0.04 | | 2005-02-28 00:00:00 | 45.88 | 46.43 | 45.82 | 46.43 | 2797300.00 | -0.01 | | 2005-03-31 00:00:00 | 45.67 | 45.70 | 45.43 | 45.61 | 2410900.00 | -0.00 | The last 5 rows are: | Date | Close | High | Low | Open | Volume | Monthly_Return | |:--------------------|--------:|-------:|------:|-------:|------------:|-----------------:| | 2025-06-30 00:00:00 | 86.00 | 86.18 | 85.37 | 85.62 | 53695200.00 | 0.03 | | 2025-07-31 00:00:00 | 85.02 | 85.50 | 84.94 | 85.22 | 49814100.00 | -0.01 | | 2025-08-31 00:00:00 | 85.03 | 85.28 | 84.87 | 85.18 | 41686400.00 | 0.00 | | 2025-09-30 00:00:00 | 88.08 | 88.74 | 87.92 | 88.37 | 38584000.00 | 0.04 | | 2025-10-31 00:00:00 | 89.30 | 89.66 | 89.21 | 89.56 | 38247300.00 | 0.01 | Next, we can plot the price history before calculating the cycle performance:\nplot_timeseries( price_df=tlt, plot_start_date=start_date, plot_end_date=end_date, plot_columns=[\u0026#34;Close\u0026#34;], title=\u0026#34;TLT Close Price\u0026#34;, x_label=\u0026#34;Date\u0026#34;, x_format=\u0026#34;Year\u0026#34;, y_label=\u0026#34;Price ($)\u0026#34;, y_format=\u0026#34;Decimal\u0026#34;, y_format_decimal_places=0, y_tick_spacing=10, grid=True, legend=False, export_plot=True, plot_file_name=\u0026#34;03_TLT_Price\u0026#34;, ) Next, we will calculate the performance for SPY based on the pre-defined Fed cycles:\ntlt_cycle_df = calc_fed_cycle_asset_performance( fed_cycles=fed_cycles, cycle_labels=cycle_labels, fed_changes=fed_changes, monthly_df=tlt_monthly, ) Which gives us:\n| | Cycle | Start | End | Months | CumulativeReturn | CumulativeReturnPct | AverageMonthlyReturn | AverageMonthlyReturnPct | AnnualizedReturn | AnnualizedReturnPct | Volatility | FedFundsChange | FedFundsChange_bps | FFR_AnnualizedChange | FFR_AnnualizedChange_bps | Label | |---:|:---------|:-----------|:-----------|---------:|-------------------:|----------------------:|-----------------------:|--------------------------:|-------------------:|----------------------:|-------------:|-----------------:|---------------------:|-----------------------:|---------------------------:|:-----------------------------------| | 0 | Cycle 1 | 2004-11-01 | 2006-07-01 | 20 | 0.04 | 4.23 | 0.00 | 0.25 | 0.03 | 2.51 | 0.09 | 0.03 | 331.00 | 0.02 | 198.60 | Cycle 1, 2004-11-01 to 2006-07-01 | | 1 | Cycle 2 | 2006-07-01 | 2007-07-01 | 12 | 0.06 | 5.76 | 0.00 | 0.49 | 0.06 | 5.76 | 0.07 | 0.00 | 2.00 | 0.00 | 2.00 | Cycle 2, 2006-07-01 to 2007-07-01 | | 2 | Cycle 3 | 2007-07-01 | 2008-12-01 | 17 | 0.32 | 32.42 | 0.02 | 1.73 | 0.22 | 21.92 | 0.14 | -0.05 | -510.00 | -0.04 | -360.00 | Cycle 3, 2007-07-01 to 2008-12-01 | | 3 | Cycle 4 | 2008-12-01 | 2015-11-01 | 83 | 0.46 | 45.67 | 0.01 | 0.55 | 0.06 | 5.59 | 0.15 | -0.00 | -4.00 | -0.00 | -0.58 | Cycle 4, 2008-12-01 to 2015-11-01 | | 4 | Cycle 5 | 2015-11-01 | 2019-01-01 | 38 | 0.07 | 7.42 | 0.00 | 0.23 | 0.02 | 2.29 | 0.10 | 0.02 | 228.00 | 0.01 | 72.00 | Cycle 5, 2015-11-01 to 2019-01-01 | | 5 | Cycle 6 | 2019-01-01 | 2019-07-01 | 6 | 0.10 | 10.48 | 0.02 | 1.73 | 0.22 | 22.05 | 0.13 | 0.00 | 0.00 | 0.00 | 0.00 | Cycle 6, 2019-01-01 to 2019-07-01 | | 6 | Cycle 7 | 2019-07-01 | 2020-04-01 | 9 | 0.26 | 26.18 | 0.03 | 2.73 | 0.36 | 36.34 | 0.18 | -0.02 | -235.00 | -0.03 | -313.33 | Cycle 7, 2019-07-01 to 2020-04-01 | | 7 | Cycle 8 | 2020-04-01 | 2022-02-01 | 22 | -0.11 | -11.33 | -0.00 | -0.50 | -0.06 | -6.35 | 0.11 | 0.00 | 3.00 | 0.00 | 1.64 | Cycle 8, 2020-04-01 to 2022-02-01 | | 8 | Cycle 9 | 2022-02-01 | 2023-08-01 | 18 | -0.27 | -26.96 | -0.02 | -1.62 | -0.19 | -18.90 | 0.17 | 0.05 | 525.00 | 0.03 | 350.00 | Cycle 9, 2022-02-01 to 2023-08-01 | | 9 | Cycle 10 | 2023-08-01 | 2024-08-01 | 12 | -0.02 | -1.52 | 0.00 | 0.02 | -0.02 | -1.52 | 0.20 | 0.00 | 0.00 | 0.00 | 0.00 | Cycle 10, 2023-08-01 to 2024-08-01 | | 10 | Cycle 11 | 2024-08-01 | 2025-12-22 | 15 | 0.00 | 0.42 | 0.00 | 0.08 | 0.00 | 0.33 | 0.11 | -0.01 | -145.00 | -0.01 | -116.00 | Cycle 11, 2024-08-01 to 2025-12-22 | This gives us the following data points:\nCycle start date Cycle end date Number of months in the cycle Cumulative return during the cycle (decimal and percent) Average monthly return during the cycle (decimal and percent) Annualized return during the cycle (decimal and percent) Return volatility during the cycle Cumulative change in FFR during the cycle (decimal and basis points) Annualized change in FFR during the cycle (decimal and basis points) From the above DataFrame, we can then plot the cumulative and annualized returns for each cycle in a bar chart. First, the cumulative returns:\nAnd then the annualized returns:\nLet\u0026rsquo;s focus our analysis on the plot comparing the annualized returns for TLT to the change in FFR. We can see that during cycles 3 and 7, the returns were very strong along with a rapid pace in cutting rates. During cycle 9, we see the opposite behavior, where as rates were increased the bond returns were very poor. The question for cycle 11, where bond returns have been essentially flat - is the pace of rate cuts not significant enough to benefit the bond market? Are there other factors at play that are influencing the long term bond returns? Keep in mind that we are also working with 20 year treasuries as well, but we could consider running analysis on investment grade or high yield corporate bonds.\nFinally, we can run an OLS regression with the following code:\ndf = tlt_cycle_df #################################### ### Don\u0026#39;t modify below this line ### #################################### # Run OLS regression with statsmodels X = df[\u0026#34;FFR_AnnualizedChange_bps\u0026#34;] y = df[\u0026#34;AnnualizedReturnPct\u0026#34;] X = sm.add_constant(X) model = sm.OLS(y, X).fit() print(model.summary()) print(f\u0026#34;Intercept: {model.params[0]}, Slope: {model.params[1]}\u0026#34;) # Intercept and slope # Calc X and Y values for regression line X_vals = np.linspace(X.min(), X.max(), 100) Y_vals = model.params[0] + model.params[1] * X_vals Which gives us the results of the OLS regression:\nOLS Regression Results =============================================================================== Dep. Variable: AnnualizedReturnPct R-squared: 0.623 Model: OLS Adj. R-squared: 0.582 Method: Least Squares F-statistic: 14.90 Date: Mon, 22 Dec 2025 Prob (F-statistic): 0.00385 Time: 20:58:55 Log-Likelihood: -39.665 No. Observations: 11 AIC: 83.33 Df Residuals: 9 BIC: 84.13 Df Model: 1 Covariance Type: nonrobust ============================================================================================ coef std err t P\u0026gt;|t| [0.025 0.975] -------------------------------------------------------------------------------------------- const 5.4676 2.978 1.836 0.100 -1.270 12.205 FFR_AnnualizedChange_bps -0.0597 0.015 -3.860 0.004 -0.095 -0.025 ============================================================================== Omnibus: 0.710 Durbin-Watson: 1.219 Prob(Omnibus): 0.701 Jarque-Bera (JB): 0.663 Skew: 0.412 Prob(JB): 0.718 Kurtosis: 2.123 Cond. No. 193. ============================================================================== Notes: [1] Standard Errors assume that the covariance matrix of the errors is correctly specified. And then plot the regression line along with the values:\nplot_scatter_regression_ffr_vs_returns( cycle_df=tlt_cycle_df, asset_label=\u0026#34;TLT\u0026#34;, index_num=\u0026#34;03\u0026#34;, x_vals=X_vals, y_vals=Y_vals, intercept=model.params[0], slope=model.params[1], ) Which gives us:\nThe above plot is intriguing because of how well the OLS regression appears to fit the data. It certainly appears that during rate-cutting cycles, bonds are an asset that performs well.\nGold (GLD) #Lastly, we\u0026rsquo;ll look at the returns on gold, using the GLD ETF as a proxy.\nFirst, we pull data with the following:\n# Set decimal places pandas_set_decimal_places(2) yf_pull_data( base_directory=DATA_DIR, ticker=\u0026#34;GLD\u0026#34;, source=\u0026#34;Yahoo_Finance\u0026#34;, asset_class=\u0026#34;Exchange_Traded_Funds\u0026#34;, excel_export=True, pickle_export=True, output_confirmation=True, ) And then load data with the following:\ngld = load_data( base_directory=DATA_DIR, ticker=\u0026#34;GLD\u0026#34;, source=\u0026#34;Yahoo_Finance\u0026#34;, asset_class=\u0026#34;Exchange_Traded_Funds\u0026#34;, timeframe=\u0026#34;Daily\u0026#34;, file_format=\u0026#34;pickle\u0026#34;, ) # Filter GLD to date range gld = gld[(gld.index \u0026gt;= pd.to_datetime(start_date)) \u0026amp; (gld.index \u0026lt;= pd.to_datetime(end_date))] # Resample to monthly frequency gld_monthly = gld.resample(\u0026#34;M\u0026#34;).last() gld_monthly[\u0026#34;Monthly_Return\u0026#34;] = gld_monthly[\u0026#34;Close\u0026#34;].pct_change() Gives us the following:\nThe columns, shape, and data types are: \u0026lt;class \u0026#39;pandas.core.frame.DataFrame\u0026#39;\u0026gt; DatetimeIndex: 252 entries, 2004-11-30 to 2025-10-31 Freq: ME Data columns (total 6 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Close 252 non-null float64 1 High 252 non-null float64 2 Low 252 non-null float64 3 Open 252 non-null float64 4 Volume 252 non-null int64 5 Monthly_Return 251 non-null float64 dtypes: float64(5), int64(1) memory usage: 13.8 KB The first 5 rows are: | Date | Close | High | Low | Open | Volume | Monthly_Return | |:--------------------|--------:|-------:|------:|-------:|-----------:|-----------------:| | 2004-11-30 00:00:00 | 45.12 | 45.41 | 44.82 | 45.37 | 3857200.00 | nan | | 2004-12-31 00:00:00 | 43.80 | 43.94 | 43.73 | 43.85 | 531600.00 | -0.03 | | 2005-01-31 00:00:00 | 42.22 | 42.30 | 41.96 | 42.21 | 1692400.00 | -0.04 | | 2005-02-28 00:00:00 | 43.53 | 43.74 | 43.52 | 43.68 | 755300.00 | 0.03 | | 2005-03-31 00:00:00 | 42.82 | 42.87 | 42.70 | 42.87 | 1363200.00 | -0.02 | The last 5 rows are: | Date | Close | High | Low | Open | Volume | Monthly_Return | |:--------------------|--------:|-------:|-------:|-------:|------------:|-----------------:| | 2025-06-30 00:00:00 | 304.83 | 304.92 | 301.95 | 302.39 | 8192100.00 | 0.00 | | 2025-07-31 00:00:00 | 302.96 | 304.61 | 302.86 | 304.59 | 8981000.00 | -0.01 | | 2025-08-31 00:00:00 | 318.07 | 318.09 | 314.64 | 314.72 | 15642600.00 | 0.05 | | 2025-09-30 00:00:00 | 355.47 | 355.57 | 350.87 | 351.13 | 13312400.00 | 0.12 | | 2025-10-31 00:00:00 | 368.12 | 370.66 | 365.50 | 370.47 | 11077900.00 | 0.04 | Next, we can plot the price history before calculating the cycle performance:\nplot_timeseries( price_df=gld, plot_start_date=start_date, plot_end_date=end_date, plot_columns=[\u0026#34;Close\u0026#34;], title=\u0026#34;GLD Close Price\u0026#34;, x_label=\u0026#34;Date\u0026#34;, x_format=\u0026#34;Year\u0026#34;, y_label=\u0026#34;Price ($)\u0026#34;, y_format=\u0026#34;Decimal\u0026#34;, y_format_decimal_places=0, y_tick_spacing=25, grid=True, legend=False, export_plot=True, plot_file_name=\u0026#34;04_GLD_Price\u0026#34;, ) Next, we will calculate the performance for SPY based on the pre-defined Fed cycles:\ngld_cycle_df = calc_fed_cycle_asset_performance( fed_cycles=fed_cycles, cycle_labels=cycle_labels, fed_changes=fed_changes, monthly_df=gld_monthly, ) Which gives us:\n| | Cycle | Start | End | Months | CumulativeReturn | CumulativeReturnPct | AverageMonthlyReturn | AverageMonthlyReturnPct | AnnualizedReturn | AnnualizedReturnPct | Volatility | FedFundsChange | FedFundsChange_bps | FFR_AnnualizedChange | FFR_AnnualizedChange_bps | Label | |---:|:---------|:-----------|:-----------|---------:|-------------------:|----------------------:|-----------------------:|--------------------------:|-------------------:|----------------------:|-------------:|-----------------:|---------------------:|-----------------------:|---------------------------:|:-----------------------------------| | 0 | Cycle 1 | 2004-11-01 | 2006-07-01 | 20 | 0.36 | 35.70 | 0.02 | 1.73 | 0.20 | 20.10 | 0.17 | 0.03 | 331.00 | 0.02 | 198.60 | Cycle 1, 2004-11-01 to 2006-07-01 | | 1 | Cycle 2 | 2006-07-01 | 2007-07-01 | 12 | 0.05 | 4.96 | 0.00 | 0.45 | 0.05 | 4.96 | 0.11 | 0.00 | 2.00 | 0.00 | 2.00 | Cycle 2, 2006-07-01 to 2007-07-01 | | 2 | Cycle 3 | 2007-07-01 | 2008-12-01 | 17 | 0.25 | 24.96 | 0.02 | 1.59 | 0.17 | 17.03 | 0.26 | -0.05 | -510.00 | -0.04 | -360.00 | Cycle 3, 2007-07-01 to 2008-12-01 | | 3 | Cycle 4 | 2008-12-01 | 2015-11-01 | 83 | 0.36 | 36.10 | 0.01 | 0.51 | 0.05 | 4.56 | 0.18 | -0.00 | -4.00 | -0.00 | -0.58 | Cycle 4, 2008-12-01 to 2015-11-01 | | 4 | Cycle 5 | 2015-11-01 | 2019-01-01 | 38 | 0.11 | 10.93 | 0.00 | 0.35 | 0.03 | 3.33 | 0.14 | 0.02 | 228.00 | 0.01 | 72.00 | Cycle 5, 2015-11-01 to 2019-01-01 | | 5 | Cycle 6 | 2019-01-01 | 2019-07-01 | 6 | 0.10 | 9.86 | 0.02 | 1.63 | 0.21 | 20.68 | 0.12 | 0.00 | 0.00 | 0.00 | 0.00 | Cycle 6, 2019-01-01 to 2019-07-01 | | 6 | Cycle 7 | 2019-07-01 | 2020-04-01 | 9 | 0.11 | 11.15 | 0.01 | 1.24 | 0.15 | 15.13 | 0.13 | -0.02 | -235.00 | -0.03 | -313.33 | Cycle 7, 2019-07-01 to 2020-04-01 | | 7 | Cycle 8 | 2020-04-01 | 2022-02-01 | 22 | 0.14 | 13.54 | 0.01 | 0.69 | 0.07 | 7.17 | 0.16 | 0.00 | 3.00 | 0.00 | 1.64 | Cycle 8, 2020-04-01 to 2022-02-01 | | 8 | Cycle 9 | 2022-02-01 | 2023-08-01 | 18 | 0.08 | 8.48 | 0.01 | 0.53 | 0.06 | 5.58 | 0.14 | 0.05 | 525.00 | 0.03 | 350.00 | Cycle 9, 2022-02-01 to 2023-08-01 | | 9 | Cycle 10 | 2023-08-01 | 2024-08-01 | 12 | 0.24 | 24.24 | 0.02 | 1.89 | 0.24 | 24.24 | 0.13 | 0.00 | 0.00 | 0.00 | 0.00 | Cycle 10, 2023-08-01 to 2024-08-01 | | 10 | Cycle 11 | 2024-08-01 | 2025-12-22 | 15 | 0.62 | 62.49 | 0.03 | 3.36 | 0.47 | 47.46 | 0.14 | -0.01 | -145.00 | -0.01 | -116.00 | Cycle 11, 2024-08-01 to 2025-12-22 | This gives us the following data points:\nCycle start date Cycle end date Number of months in the cycle Cumulative return during the cycle (decimal and percent) Average monthly return during the cycle (decimal and percent) Annualized return during the cycle (decimal and percent) Return volatility during the cycle Cumulative change in FFR during the cycle (decimal and basis points) Annualized change in FFR during the cycle (decimal and basis points) From the above DataFrame, we can then plot the cumulative and annualized returns for each cycle in a bar chart. First, the cumulative returns:\nAnd then the annualized returns:\nWe see strong returns for gold across several different Fed cycles, so it is difficult to draw any kind of initial conclusion based on the bar charts.\nFinally, we can run an OLS regression with the following code:\ndf = gld_cycle_df #################################### ### Don\u0026#39;t modify below this line ### #################################### # Run OLS regression with statsmodels X = df[\u0026#34;FFR_AnnualizedChange_bps\u0026#34;] y = df[\u0026#34;AnnualizedReturnPct\u0026#34;] X = sm.add_constant(X) model = sm.OLS(y, X).fit() print(model.summary()) print(f\u0026#34;Intercept: {model.params[0]}, Slope: {model.params[1]}\u0026#34;) # Intercept and slope # Calc X and Y values for regression line X_vals = np.linspace(X.min(), X.max(), 100) Y_vals = model.params[0] + model.params[1] * X_vals Which gives us the results of the OLS regression:\nOLS Regression Results =============================================================================== Dep. Variable: AnnualizedReturnPct R-squared: 0.084 Model: OLS Adj. R-squared: -0.018 Method: Least Squares F-statistic: 0.8274 Date: Mon, 22 Dec 2025 Prob (F-statistic): 0.387 Time: 20:58:59 Log-Likelihood: -42.830 No. Observations: 11 AIC: 89.66 Df Residuals: 9 BIC: 90.46 Df Model: 1 Covariance Type: nonrobust ============================================================================================ coef std err t P\u0026gt;|t| [0.025 0.975] -------------------------------------------------------------------------------------------- const 15.1947 3.972 3.826 0.004 6.210 24.179 FFR_AnnualizedChange_bps -0.0187 0.021 -0.910 0.387 -0.065 0.028 ============================================================================== Omnibus: 8.035 Durbin-Watson: 0.915 Prob(Omnibus): 0.018 Jarque-Bera (JB): 3.686 Skew: 1.328 Prob(JB): 0.158 Kurtosis: 3.993 Cond. No. 193. ============================================================================== Notes: [1] Standard Errors assume that the covariance matrix of the errors is correctly specified. And then plot the regression line along with the values:\nplot_scatter_regression_ffr_vs_returns( cycle_df=gld_cycle_df, asset_label=\u0026#34;GLD\u0026#34;, index_num=\u0026#34;04\u0026#34;, x_vals=X_vals, y_vals=Y_vals, intercept=model.params[0], slope=model.params[1], ) Which gives us:\nIt\u0026rsquo;s difficult to draw any strong conclusions with the above plot. Gold has traditionally been considered a hedge for inflation, and while one of the Fed\u0026rsquo;s mandates is to manage inflation, there may not be a conclusion to draw in relationship to the historical returns that gold has exhibited.\nHybrid Portfolio #With the above analysis (somewhat) complete, let\u0026rsquo;s look at the optimal allocation for a portfolio based on the data and the hypythetical historical results.\nRecall the plots for annualized returns vs annualized change in FFR for stocks, bonds, and gold:\nAsset Allocation #We have to be careful with our criteria for when to hold stocks, bonds, or gold, as hindsight bias is certainly possible. So, without overanalyzing the results, let\u0026rsquo;s assume that we hold stocks as the default position, and then hold bonds when the Fed starts cutting rates, and then resume holding stocks when the Fed stops cutting rates. If there is not any change in FFR, then we still hold stocks. That gives us:\nCycle 1: Stocks Cycle 2: Stocks Cycle 3: Bonds Cycle 4: Stocks Cycle 5: Stocks Cycle 6: Stocks Cycle 7: Bonds Cycle 8: Stocks Cycle 9: Stocks Cycle 10: Stocks Cycle 11: Bonds We can then combine the return series based on the above with the following code:\n# Calculate cumulative returns and drawdown for SPY spy_monthly[\u0026#39;Cumulative_Return\u0026#39;] = (1 + spy_monthly[\u0026#39;Monthly_Return\u0026#39;]).cumprod() - 1 spy_monthly[\u0026#39;Cumulative_Return_Plus_One\u0026#39;] = 1 + spy_monthly[\u0026#39;Cumulative_Return\u0026#39;] spy_monthly[\u0026#39;Rolling_Max\u0026#39;] = spy_monthly[\u0026#39;Cumulative_Return_Plus_One\u0026#39;].cummax() spy_monthly[\u0026#39;Drawdown\u0026#39;] = spy_monthly[\u0026#39;Cumulative_Return_Plus_One\u0026#39;] / spy_monthly[\u0026#39;Rolling_Max\u0026#39;] - 1 spy_monthly.drop(columns=[\u0026#39;Cumulative_Return_Plus_One\u0026#39;, \u0026#39;Rolling_Max\u0026#39;], inplace=True) # Calculate cumulative returns and drawdown for TLT tlt_monthly[\u0026#39;Cumulative_Return\u0026#39;] = (1 + tlt_monthly[\u0026#39;Monthly_Return\u0026#39;]).cumprod() - 1 tlt_monthly[\u0026#39;Cumulative_Return_Plus_One\u0026#39;] = 1 + tlt_monthly[\u0026#39;Cumulative_Return\u0026#39;] tlt_monthly[\u0026#39;Rolling_Max\u0026#39;] = tlt_monthly[\u0026#39;Cumulative_Return_Plus_One\u0026#39;].cummax() tlt_monthly[\u0026#39;Drawdown\u0026#39;] = tlt_monthly[\u0026#39;Cumulative_Return_Plus_One\u0026#39;] / tlt_monthly[\u0026#39;Rolling_Max\u0026#39;] - 1 tlt_monthly.drop(columns=[\u0026#39;Cumulative_Return_Plus_One\u0026#39;, \u0026#39;Rolling_Max\u0026#39;], inplace=True) # Isolate the returns for SPY and TLT spy_ret = spy_monthly[\u0026#39;Monthly_Return\u0026#39;] tlt_ret = tlt_monthly[\u0026#39;Monthly_Return\u0026#39;] # Create a blended portfolio based on Fed policy cycles portfolio = ( spy_ret[spy_ret.index \u0026lt;= \u0026#34;2007-07-01\u0026#34;] .combine_first(tlt_ret[(tlt_ret.index \u0026gt;= \u0026#34;2007-07-01\u0026#34;) \u0026amp; (tlt_ret.index \u0026lt;= \u0026#34;2008-12-01\u0026#34;)]) .combine_first(spy_ret[(spy_ret.index \u0026gt; \u0026#34;2008-12-01\u0026#34;) \u0026amp; (spy_ret.index \u0026lt;= \u0026#34;2019-07-01\u0026#34;)]) .combine_first(tlt_ret[(tlt_ret.index \u0026gt;= \u0026#34;2019-07-01\u0026#34;) \u0026amp; (tlt_ret.index \u0026lt;= \u0026#34;2020-04-01\u0026#34;)]) .combine_first(spy_ret[(spy_ret.index \u0026gt; \u0026#34;2020-04-01\u0026#34;) \u0026amp; (spy_ret.index \u0026lt;= \u0026#34;2024-08-01\u0026#34;)]) .combine_first(tlt_ret[tlt_ret.index \u0026gt; \u0026#34;2024-08-01\u0026#34;]) ) # Convert to DataFrame portfolio_monthly = portfolio.to_frame(name=\u0026#34;Portfolio_Monthly_Return\u0026#34;) # Calculate cumulative returns and drawdown for the portfolio portfolio_monthly[\u0026#39;Portfolio_Cumulative_Return\u0026#39;] = (1 + portfolio_monthly[\u0026#39;Portfolio_Monthly_Return\u0026#39;]).cumprod() - 1 portfolio_monthly[\u0026#39;Portfolio_Cumulative_Return_Plus_One\u0026#39;] = 1 + portfolio_monthly[\u0026#39;Portfolio_Cumulative_Return\u0026#39;] portfolio_monthly[\u0026#39;Portfolio_Rolling_Max\u0026#39;] = portfolio_monthly[\u0026#39;Portfolio_Cumulative_Return_Plus_One\u0026#39;].cummax() portfolio_monthly[\u0026#39;Portfolio_Drawdown\u0026#39;] = portfolio_monthly[\u0026#39;Portfolio_Cumulative_Return_Plus_One\u0026#39;] / portfolio_monthly[\u0026#39;Portfolio_Rolling_Max\u0026#39;] - 1 portfolio_monthly.drop(columns=[\u0026#39;Portfolio_Cumulative_Return_Plus_One\u0026#39;, \u0026#39;Portfolio_Rolling_Max\u0026#39;], inplace=True) # Merge \u0026#34;spy_monthly\u0026#34; and \u0026#34;tlt_monthly\u0026#34; into \u0026#34;portfolio_monthly\u0026#34; to compare cumulative returns portfolio_monthly = portfolio_monthly.join( spy_monthly[\u0026#39;Monthly_Return\u0026#39;].rename(\u0026#39;SPY_Monthly_Return\u0026#39;), how=\u0026#39;left\u0026#39; ).join( spy_monthly[\u0026#39;Cumulative_Return\u0026#39;].rename(\u0026#39;SPY_Cumulative_Return\u0026#39;), how=\u0026#39;left\u0026#39; ).join( spy_monthly[\u0026#39;Drawdown\u0026#39;].rename(\u0026#39;SPY_Drawdown\u0026#39;), how=\u0026#39;left\u0026#39; ).join( tlt_monthly[\u0026#39;Monthly_Return\u0026#39;].rename(\u0026#39;TLT_Monthly_Return\u0026#39;), how=\u0026#39;left\u0026#39; ).join( tlt_monthly[\u0026#39;Cumulative_Return\u0026#39;].rename(\u0026#39;TLT_Cumulative_Return\u0026#39;), how=\u0026#39;left\u0026#39; ).join( tlt_monthly[\u0026#39;Drawdown\u0026#39;].rename(\u0026#39;TLT_Drawdown\u0026#39;), how=\u0026#39;left\u0026#39; ) Which gives us:\nThe columns, shape, and data types are: \u0026lt;class \u0026#39;pandas.core.frame.DataFrame\u0026#39;\u0026gt; DatetimeIndex: 252 entries, 2004-11-30 to 2025-10-31 Freq: ME Data columns (total 9 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Portfolio_Monthly_Return 251 non-null float64 1 Portfolio_Cumulative_Return 251 non-null float64 2 Portfolio_Drawdown 251 non-null float64 3 SPY_Monthly_Return 251 non-null float64 4 SPY_Cumulative_Return 251 non-null float64 5 SPY_Drawdown 251 non-null float64 6 TLT_Monthly_Return 251 non-null float64 7 TLT_Cumulative_Return 251 non-null float64 8 TLT_Drawdown 251 non-null float64 dtypes: float64(9) memory usage: 19.7 KB The first 5 rows are: | Date | Portfolio_Monthly_Return | Portfolio_Cumulative_Return | Portfolio_Drawdown | SPY_Monthly_Return | SPY_Cumulative_Return | SPY_Drawdown | TLT_Monthly_Return | TLT_Cumulative_Return | TLT_Drawdown | |:--------------------|---------------------------:|------------------------------:|---------------------:|---------------------:|------------------------:|---------------:|---------------------:|------------------------:|---------------:| | 2004-11-30 00:00:00 | nan | nan | nan | nan | nan | nan | nan | nan | nan | | 2004-12-31 00:00:00 | 0.030 | 0.030 | 0.000 | 0.030 | 0.030 | 0.000 | 0.027 | 0.027 | 0.000 | | 2005-01-31 00:00:00 | -0.022 | 0.007 | -0.022 | -0.022 | 0.007 | -0.022 | 0.036 | 0.063 | 0.000 | | 2005-02-28 00:00:00 | 0.021 | 0.028 | -0.002 | 0.021 | 0.028 | -0.002 | -0.015 | 0.048 | -0.015 | | 2005-03-31 00:00:00 | -0.018 | 0.009 | -0.020 | -0.018 | 0.009 | -0.020 | -0.005 | 0.043 | -0.019 | The last 5 rows are: | Date | Portfolio_Monthly_Return | Portfolio_Cumulative_Return | Portfolio_Drawdown | SPY_Monthly_Return | SPY_Cumulative_Return | SPY_Drawdown | TLT_Monthly_Return | TLT_Cumulative_Return | TLT_Drawdown | |:--------------------|---------------------------:|------------------------------:|---------------------:|---------------------:|------------------------:|---------------:|---------------------:|------------------------:|---------------:| | 2025-06-30 00:00:00 | 0.027 | 19.004 | -0.072 | 0.051 | 6.718 | 0.000 | 0.027 | 0.963 | -0.408 | | 2025-07-31 00:00:00 | -0.011 | 18.776 | -0.082 | 0.023 | 6.896 | 0.000 | -0.011 | 0.941 | -0.415 | | 2025-08-31 00:00:00 | 0.000 | 18.778 | -0.082 | 0.021 | 7.058 | 0.000 | 0.000 | 0.941 | -0.415 | | 2025-09-30 00:00:00 | 0.036 | 19.489 | -0.049 | 0.036 | 7.345 | 0.000 | 0.036 | 1.011 | -0.394 | | 2025-10-31 00:00:00 | 0.014 | 19.772 | -0.036 | 0.024 | 7.544 | 0.000 | 0.014 | 1.039 | -0.385 | Next, we\u0026rsquo;ll look at performance for the assets and portfolio.\nPerformance Statistics #We can then plot the monthly returns:\nAnd cumulative returns:\nAnd drawdowns:\nFinally, we can run the stats on the hybrid portfolio, SPY, and TLT with the following code:\nport_sum_stats = summary_stats( fund_list=[\u0026#34;Portfolio\u0026#34;, \u0026#34;SPY\u0026#34;, \u0026#34;TLT\u0026#34;], df=portfolio_monthly[[\u0026#34;Portfolio_Monthly_Return\u0026#34;]], period=\u0026#34;Monthly\u0026#34;, use_calendar_days=False, excel_export=False, pickle_export=False, output_confirmation=False, ) spy_sum_stats = summary_stats( fund_list=[\u0026#34;Portfolio\u0026#34;, \u0026#34;SPY\u0026#34;, \u0026#34;TLT\u0026#34;], df=portfolio_monthly[[\u0026#34;SPY_Monthly_Return\u0026#34;]], period=\u0026#34;Monthly\u0026#34;, use_calendar_days=False, excel_export=False, pickle_export=False, output_confirmation=False, ) tlt_sum_stats = summary_stats( fund_list=[\u0026#34;Portfolio\u0026#34;, \u0026#34;SPY\u0026#34;, \u0026#34;TLT\u0026#34;], df=portfolio_monthly[[\u0026#34;TLT_Monthly_Return\u0026#34;]], period=\u0026#34;Monthly\u0026#34;, use_calendar_days=False, excel_export=False, pickle_export=False, output_confirmation=False, ) sum_stats = port_sum_stats.combine_first(spy_sum_stats).combine_first(tlt_sum_stats) Which gives us:\n| | Annualized Mean | Annualized Volatility | Annualized Sharpe Ratio | CAGR | Monthly Max Return | Monthly Max Return (Date) | Monthly Min Return | Monthly Min Return (Date) | Max Drawdown | Peak | Trough | Recovery Date | Days to Recover | MAR Ratio | |:-------------------------|------------------:|------------------------:|--------------------------:|-------:|---------------------:|:----------------------------|---------------------:|:----------------------------|---------------:|:--------------------|:--------------------|:--------------------|------------------:|------------:| | Portfolio_Monthly_Return | 0.156 | 0.140 | 1.111 | 0.155 | 0.143 | 2008-11-30 00:00:00 | -0.107 | 2009-02-28 00:00:00 | -0.239 | 2021-12-31 00:00:00 | 2022-09-30 00:00:00 | 2023-12-31 00:00:00 | 457.000 | 0.650 | | SPY_Monthly_Return | 0.114 | 0.148 | 0.769 | 0.108 | 0.127 | 2020-04-30 00:00:00 | -0.165 | 2008-10-31 00:00:00 | -0.508 | 2007-10-31 00:00:00 | 2009-02-28 00:00:00 | 2012-03-31 00:00:00 | 1127.000 | 0.212 | | TLT_Monthly_Return | 0.043 | 0.137 | 0.316 | 0.035 | 0.143 | 2008-11-30 00:00:00 | -0.131 | 2009-01-31 00:00:00 | -0.476 | 2020-07-31 00:00:00 | 2023-10-31 00:00:00 | NaT | nan | 0.072 | Based on the above, our hybrid portfolio outperforms both stocks and bonds, and by a wide margin.\nFuture Investigation #A couple of ideas sound intriguing for future investigation:\nDo investment grade or high yield bonds show a different behavior than the long term US treasury bonds? Does a commodity index (such as GSCI) exhibit differing behavior than gold? How does leverage affect the returns that are observed for the hybrid portfolio, stocks, and bonds? Do other Fed tightening/loosening cycles exhibit the same behavior for returns? References # https://fred.stlouisfed.org/series/FEDFUNDS Code #The jupyter notebook with the functions and all other code is available here. The html export of the jupyter notebook is available here. The pdf export of the jupyter notebook is available here.\n","date":"November 29, 2025","permalink":"https://jaredszajkowski.github.io/jaredszajkowski.github.io_congo/posts/asset-class-performance-fed-policy-cycles/","section":"Posts","summary":"How does the performance of stocks, bonds, and other asset classes vary during Fed policy cycles?","title":"Performance Of Various Asset Classes During Fed Policy Cycles"},{"content":"","date":null,"permalink":"https://jaredszajkowski.github.io/jaredszajkowski.github.io_congo/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":null,"permalink":"https://jaredszajkowski.github.io/jaredszajkowski.github.io_congo/topics/python/","section":"Topics","summary":"","title":"Python"},{"content":"","date":null,"permalink":"https://jaredszajkowski.github.io/jaredszajkowski.github.io_congo/topics/","section":"Topics","summary":"","title":"Topics"},{"content":"","date":null,"permalink":"https://jaredszajkowski.github.io/jaredszajkowski.github.io_congo/topics/yahoo-finance/","section":"Topics","summary":"","title":"Yahoo Finance"},{"content":"Profile #Jared is a seasoned civil engineer with extensive experience in infrastructure design and construction, specifically within the heavy highway and telecommunications sectors. With a strong foundation in field operations, contract administration, and project cost forecasting, Jared has consistently demonstrated the ability to drive projects to success through aggressive problem-solving and meticulous planning.\nAfter spending the first part of his career in engineering, Jared decided to follow his passion for financial markets by enrolling in the Financial Mathematics graduate program at the University of Chicago in the fall of 2022. This rigorous program, known for its emphasis on quantitative analysis, stochastic processes, and financial modeling, has equipped Jared with advanced skills in data-driven decision-making, risk management, and derivative pricing. He will complete the program in the spring of 2026.\nJared aims to leverage his prior professional experience, analytical skills, business acumen, and attention to detail to a new career in the financial services industry.\nUndergraduate Education #Jared graduated from the Illinois Institue of Technology with a Bachelor of Science (BS) in Civil Engineering.\nGraduate Education #Jared has completed the following graduate courses in the Univeristy of Chicago Financial Mathematics program:\nFINM 34000 - Probability and Stochastic Processes FINM 36700 - Portfolio and Risk Management FINM 32500 - Computing for Finance in Python FINM 32600 - Computing for Finance in C++ FINM 32700 - Advanced Computing for Finance FINM 33000 - Option Pricing FINM 33150 - Quantitative Trading Strategy Example coursework: The final group project consisted of developing a trading strategy incorporating the following: Creating criteria and evaluating potential trades Establishing position sizes, entry, and exit rules Minimum of 5 different assets (NOT asset classes) Use of leverage Produce a \u0026ldquo;paper\u0026rdquo; in Jupyter Notebook, HTML Produce a PDF pitch book From the abstract: The final project seeks to develop a systematic trading/investment strategy that takes advantage of the time-tested market ideas that the market tends to increase in price/value over time, positive earnings growth tends to increase company valuation, companies with positive earnings growth tend to exhibit upward price momentum. When companies have lower earnings, they tend to have lower valuations which provides an opportunity for the value factor to take effect.\nFINM 35900 - Macro-Finance Example coursework: The final group project consisted of selecting a fund or company and improving the fund with respect to macro/multi-asset ideas. The deliverables included: A concise PDF write-up with appendicies A slide deck Final calculations in Jupyter Notebook, HTML From the abstract: This proposal examines the potential benefits of incorporating Bitcoin into the asset allocation strategy of the Illinois State Board of Investment (ISBI). With over $25 billion in assets under management and a significant responsibility for managing pension plans for State of Illinois employees, ISBI\u0026rsquo;s investment policy warrants periodic review and adjustment to optimize returns and manage risk. This study suggests initializing a 1% allocation of the fund\u0026rsquo;s assets to Bitcoin as part of a diversified portfolio, alongside current assets.\nFINM 37301 - Foreign Exchange: Markets, Products, and Pricing FINM 35910 - Applied Algorithmic Trading Example coursework: The final group project was to \u0026ldquo;develop and present a fictional fund focusing on alternative algorithmic trading strategies.\u0026rdquo; The strategy was to provide \u0026ldquo;uncorrelated return relative to the S\u0026amp;P 500 Index through robust strategy creation, risk management, and performance metrics.\u0026rdquo; Final presesntation slide deck Final calculations in Jupyter Notebook, HTML From the fund prospectus: Part-Time Trading LLC is an investment firm focusing on developing machine-learning models to actively predict prices within cryptocurrency markets. Our funds objective is to extract predictive features from crypto market data and utilize these features to develop best in class predictive machine learning models. Currently, we are focusing our trading efforts on trading Bitcoin and Ethereum on the crypto exchange Kraken. As we continue to advance our proprietary research and models, we plan to expand into other cryptocurrencies and exchanges.Our trading system is designed to deliver consistent alpha by exploiting inefficiencies and opportunities in the highly volatile and liquid crypto markets. Our objective is to maximize returns while minimizing risk through data-driven decision making and robust predictive analytics.\nFINM 31200 - Blockchain and Cryptoassets for Finance FINM 32900 - Full-Stack Quantitative Finance BUSN 41204 - Machine Learning (search \u0026ldquo;41204\u0026rdquo; in the search under \u0026ldquo;Course Number\u0026rdquo;) Jared currently plans to graduate in the spring of 2026 after completing the following courses:\nFINM 36000 - Project Lab FINM 37400 - Fixed Income FINM 35700 - Credit Markets Professional Certifications #Jared currently holds the following professional certifications:\nProfessional Engineer (PE), Illinois Department of Financial and Professional Regulation, License Number 062073506 Project Management Professional (PMP), Project Management Institute, License Number 2595125 ","date":null,"permalink":"https://jaredszajkowski.github.io/jaredszajkowski.github.io_congo/about-me/","section":"Pages","summary":"","title":"About Me"},{"content":"Software #Here are some links to software, etc. that I find interesting and use.\nGitHub: GitHub is the world\u0026rsquo;s largest software development platform. Gnome Apps: Apps for GNOME. Arch Linux: Arch Linux - A simple, lightweight distribution. LibreOffice: LibreOffice includes several applications that make it the most versatile Free and Open Source office suite available, including Writer (word processing), Calc (spreadsheets), Impress (presentations), Draw (vector graphics and flowcharts), Base (databases), and Math (formula editing). Master PDF Editor: Master PDF Editor is straightforward, easy to use application for working with PDF documents equipped with powerful multi-purpose functionality. With Master PDF Editor you can easily view, create and modify PDF documents. The application enables you to merge several files into one, split a source document into multiple documents, and also to comment, sign and encrypt PDF files. digiKam: digiKam is an advanced open-source digital photo management application that runs on Linux, Windows, and macOS. The application provides a comprehensive set of tools for importing, managing, editing, and sharing photos and raw files. Thunderbird: Thunderbird is a free and open source email, newsfeed, chat, and calendaring client, thats easy to set up and customize. One of the core principles of Thunderbird is the use and promotion of open standards - this focus is a rejection of our world of closed platforms and services that cant communicate with each other. We want our users to have freedom and choice in how they communicate. pandas: pandas is a fast, powerful, flexible and easy to use open source data analysis and manipulation tool, built on top of the Python programming language. ","date":null,"permalink":"https://jaredszajkowski.github.io/jaredszajkowski.github.io_congo/links/","section":"Pages","summary":"","title":"Links"},{"content":"","date":null,"permalink":"https://jaredszajkowski.github.io/jaredszajkowski.github.io_congo/pages/","section":"Pages","summary":"","title":"Pages"}]